---
alwaysApply: true
---

# Clean Architecture Rules - Vita Product Boilerplate

This workspace follows Advanced Clean Architecture with SOLID principles, Apollo Client, and Functional Patterns.

## Layer Structure

```
packages/
├── domain/              # Domain entities (Zod) + repository interfaces (contracts) + Result Pattern
├── application/         # Pure Use Cases (orchestration) + Hooks
├── infrastructure/      # Technical implementations (Apollo Client repositories, adapters)
├── graphql/             # Generated GraphQL documents/types (shared)
└── ui/                  # Shared UI primitives

apps/
├── web/                 # Presentation (Next.js) + Composition Root
└── mobile/              # Presentation (Expo) + Composition Root
```

## Rules by Layer

### Domain Layer (`@repo/domain`)
**The heart of the application. Pure TypeScript.**

- ✅ Define entities using **Zod** for schema validation and type safety.
- ✅ Declare **repository interfaces** (abstract contracts).
- ✅ Use the **Result Pattern** (`{ ok: true, value: T } | { ok: false, error: E }`) for domain errors.
- ❌ FORBIDDEN: Frameworks, Apollo Client, Infrastructure details, external libraries (except Zod).

### Application Layer (`@repo/application`)
**Orchestrates business rules. Framework-agnostic.**

#### Use Cases (`use-cases/`)
- ✅ Implement business logic in pure classes.
- ✅ Depend only on repository interfaces (Dependency Inversion).
- ✅ Return `Result` types.
- ❌ FORBIDDEN: React components, Apollo hooks, UI logic.

#### Hooks (`hooks/`)
- ✅ Orchestrate Use Cases and Repositories.
- ✅ Manage React state (loading, error, data).
- ✅ Return standard format: `{ data, isLoading, isError, error, refetch }`.

### Infrastructure Layer (`@repo/infrastructure`)
**External world implementations.**

- ✅ Implement repository interfaces using **Apollo Client** or other tools.
- ✅ Map external data formats to Domain Entities using **Mappers**.
- ✅ Handle technical errors and convert them to Domain Errors.

### Presentation Layer (apps)
**The "Imperative Shell".**

- ✅ React components (Next.js / Expo).
- ✅ **Composition Root**: Instantiate repositories and use cases here (via `useMemo` or Providers).
- ✅ Use hooks from `@repo/application`.
- ❌ FORBIDDEN: Define GraphQL queries, business logic, or direct repository access.

## Dependency Flow

```mermaid
graph LR
    Apps[Apps / Presentation] --> AppPkg[@repo/application]
    Apps --> InfraPkg[@repo/infrastructure]
    AppPkg --> DomainPkg[@repo/domain]
    InfraPkg --> DomainPkg
```

- `@repo/domain` is the most stable and has NO dependencies.
- `@repo/application` depends only on `@repo/domain`.
- `@repo/infrastructure` depends on `@repo/domain` (to implement interfaces).
- `Apps` connect everything (Composition Root).

## Conventions

### Naming
- Entities: PascalCase (`Task`).
- Schemas: `{Entity}Schema` (`TaskSchema`).
- Repository Interfaces: `{Entity}RepositoryInterface`.
- Use Cases: `{Action}{Entity}UseCase` (`GetTasksUseCase`).
- Implementations: `{Tech}{Entity}Repository` (`ApolloTaskRepository`).

### Error Handling (Result Pattern)
Always return a `Result` from Use Cases and Repositories instead of throwing.

```typescript
// use-case
async execute(): Promise<Result<Task[]>> { ... }

// hook consumption
const result = await useCase.execute();
if (result.ok) { /* success */ } else { /* handle error */ }
```

## IMPORTANT
- **ALWAYS** use Zod for domain entity definitions.
- **ALWAYS** return `Result` types for error handling.
- **ALWAYS** inject repositories into use cases (Dependency Inversion).
- **NEVER** import from `apps/` or `@repo/infrastructure` inside `@repo/application`.

## Additional mandatory rules

- **TDD is mandatory** for all new feature code. See: `.cursor/rules/tdd-rules.mdc`
- **Documentation is mandatory** (bilingual) for new features. See: `.cursor/rules/docs-rules.mdc`
