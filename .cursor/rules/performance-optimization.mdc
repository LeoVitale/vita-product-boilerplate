---
description: Decision framework for performance optimizations - when to apply and when to skip
globs:
  - 'packages/infrastructure/**/*.ts'
  - 'apps/web/**/*.{ts,tsx}'
  - 'apps/mobile/**/*.{ts,tsx}'
alwaysApply: false
---

# Performance Optimization Decision Framework

Use this guide **during development** to evaluate if performance optimizations are worth implementing. Not every optimization is worth the complexity - evaluate based on **real impact**, not theoretical benefits.

## Decision Criteria

Before implementing any optimization, ask:

1. **Is there a measurable problem?** (Lighthouse score < 90, bundle size > 500KB, slow API calls)
2. **Will users notice the difference?** (Is it > 100ms improvement?)
3. **What's the maintenance cost?** (Will it make code harder to understand?)
4. **Is it premature?** (Are we optimizing before having real usage data?)

## Optimization Categories

### üü¢ High ROI - Usually Worth It

These optimizations have high impact with low complexity:

#### 1. Apollo Cache Type Policies

**When to apply:**

- ‚úÖ You have entities with relationships (Task ‚Üí User, Order ‚Üí Product)
- ‚úÖ You're doing `refetchQueries` after mutations
- ‚úÖ You have multiple queries fetching the same entity

**When to skip:**

- ‚ùå Simple CRUD with no relationships
- ‚ùå Single query per entity
- ‚ùå Data changes rarely

**Decision checklist:**

- [ ] Do I have entities that appear in multiple queries?
- [ ] Am I using `refetchQueries` after mutations?
- [ ] Would cache normalization reduce duplicate requests?

**Example:**

```typescript
// ‚úÖ Apply when: Task appears in list + detail queries
cache: new InMemoryCache({
  typePolicies: {
    Task: {
      keyFields: ['id'],
    },
  },
});

// ‚ùå Skip when: Only one query per entity, no relationships
```

#### 2. Optimistic Updates (Mutations)

**When to apply:**

- ‚úÖ Mutations that users trigger frequently (toggle, like, favorite)
- ‚úÖ Network latency > 200ms
- ‚úÖ Users expect instant feedback

**When to skip:**

- ‚ùå Critical operations (delete, payment)
- ‚ùå Complex mutations with side effects
- ‚ùå Low-frequency operations

**Decision checklist:**

- [ ] Is this mutation triggered frequently by users?
- [ ] Can I predict the result accurately?
- [ ] What happens if the mutation fails? (Can I rollback?)

**Example:**

```typescript
// ‚úÖ Apply: Toggle task completion (frequent, predictable)
optimisticResponse: {
  toggleTaskComplete: {
    ...task,
    completed: !task.completed,
  },
}

// ‚ùå Skip: Delete task (critical, needs confirmation)
```

#### 3. Dynamic Imports (Code Splitting)

**When to apply:**

- ‚úÖ Components > 50KB (check bundle analyzer)
- ‚úÖ Routes/pages not accessed by all users
- ‚úÖ Heavy third-party libraries (charts, editors)

**When to skip:**

- ‚ùå Small components (< 10KB)
- ‚ùå Above-the-fold content
- ‚ùå Frequently used components

**Decision checklist:**

- [ ] What's the bundle size? (`pnpm build` + analyze)
- [ ] Is this component used by < 50% of users?
- [ ] Can users wait 100-200ms for it to load?

**Example:**

```typescript
// ‚úÖ Apply: Admin dashboard (used by < 10% of users)
const AdminDashboard = dynamic(() => import('./AdminDashboard'), {
  loading: () => <Loading />,
  ssr: false,
})

// ‚ùå Skip: Navigation bar (used by 100% of users)
```

### üü° Medium ROI - Evaluate Case-by-Case

These optimizations have moderate impact but higher complexity:

#### 4. Apollo Cache Persistence

**When to apply:**

- ‚úÖ Mobile apps (offline-first)
- ‚úÖ Users frequently return to same data
- ‚úÖ Data changes slowly (catalog, settings)

**When to skip:**

- ‚ùå Real-time data (chat, notifications)
- ‚ùå Sensitive data (auth tokens)
- ‚ùå Data changes frequently

**Decision checklist:**

- [ ] Do users need offline access?
- [ ] How often does data change?
- [ ] Is data sensitive?

**Example:**

```typescript
// ‚úÖ Apply: Product catalog (changes weekly, users browse offline)
import { persistCache } from 'apollo3-cache-persist';

// ‚ùå Skip: Real-time chat (changes every second)
```

#### 5. Next.js Image Optimization

**When to apply:**

- ‚úÖ You have > 10 images per page
- ‚úÖ Images are > 100KB each
- ‚úÖ Images are user-generated (need optimization)

**When to skip:**

- ‚ùå Few images (< 5 per page)
- ‚ùå Already optimized images (SVG, WebP)
- ‚ùå Images from CDN with optimization

**Decision checklist:**

- [ ] How many images per page?
- [ ] Average image size?
- [ ] Are images already optimized?

**Example:**

```typescript
// ‚úÖ Apply: Product gallery with 20+ images
import Image from 'next/image';

// ‚ùå Skip: Logo and 2 icons (already SVG)
```

#### 6. Query Result Memoization

**When to apply:**

- ‚úÖ Expensive computations in hooks
- ‚úÖ Same data used in multiple components
- ‚úÖ Data doesn't change frequently

**When to skip:**

- ‚ùå Simple data transformations
- ‚ùå Data changes frequently
- ‚ùå Already memoized by Apollo

**Decision checklist:**

- [ ] Is computation expensive? (> 10ms)
- [ ] Is data used in multiple places?
- [ ] Does Apollo already cache this?

**Example:**

```typescript
// ‚úÖ Apply: Filtering/sorting large lists (> 100 items)
const filteredTasks = useMemo(() => tasks.filter((t) => t.completed), [tasks]);

// ‚ùå Skip: Simple mapping (< 10 items)
```

### üî¥ Low ROI - Usually Skip (Unless Proven Need)

These optimizations have low impact or high complexity:

#### 7. Manual Cache Updates (Instead of refetchQueries)

**When to apply:**

- ‚úÖ You've measured that `refetchQueries` is slow (> 500ms)
- ‚úÖ You have complex cache relationships
- ‚úÖ You need fine-grained control

**When to skip:**

- ‚ùå `refetchQueries` works fine (< 200ms)
- ‚ùå Simple cache structure
- ‚ùå Early in development

**Decision checklist:**

- [ ] Have I measured `refetchQueries` performance?
- [ ] Is it actually slow?
- [ ] Is the complexity worth it?

**Example:**

```typescript
// ‚úÖ Apply: After measuring slow refetchQueries
update: (cache, { data }) => {
  // Complex cache update logic
};

// ‚ùå Skip: refetchQueries works fine, keep it simple
refetchQueries: [{ query: GetTasksDocument }];
```

#### 8. Service Workers / PWA

**When to apply:**

- ‚úÖ Mobile-first app
- ‚úÖ Offline functionality is core feature
- ‚úÖ Users need app-like experience

**When to skip:**

- ‚ùå Desktop-only app
- ‚ùå Always-online requirement
- ‚ùå Early MVP stage

#### 9. Bundle Size Micro-optimizations

**When to apply:**

- ‚úÖ Bundle > 1MB (after compression)
- ‚úÖ Lighthouse score < 70
- ‚úÖ Users on slow connections (mobile, 3G)

**When to skip:**

- ‚ùå Bundle < 500KB
- ‚ùå Desktop-only app
- ‚ùå Internal tools

## Performance Review Checklist

Use this checklist **monthly** or when performance issues arise:

### Initial Setup (Do Once)

- [ ] Set up bundle analyzer (`@next/bundle-analyzer`)
- [ ] Configure Lighthouse CI (or manual checks)
- [ ] Set up Web Vitals monitoring (Vercel Analytics or custom)
- [ ] Document baseline metrics (bundle size, Lighthouse score)

### Apollo Client

- [ ] Review `refetchQueries` usage - can any be replaced with optimistic updates?
- [ ] Check if Type Policies would help with cache normalization
- [ ] Evaluate cache persistence for mobile apps
- [ ] Measure mutation performance - are they slow?

### Next.js

- [ ] Run bundle analyzer - identify large dependencies
- [ ] Check Lighthouse score - target > 90
- [ ] Review dynamic imports - are heavy components lazy-loaded?
- [ ] Verify Image component usage for user-generated images

### Code Quality

- [ ] Review expensive computations - are they memoized?
- [ ] Check for unnecessary re-renders (React DevTools Profiler)
- [ ] Evaluate if any optimizations add unnecessary complexity

## Metrics to Track

### Bundle Size

- **Target:** < 500KB (gzipped) for initial load
- **Action:** If > 500KB, use bundle analyzer to find culprits

### Lighthouse Score

- **Target:** > 90 for Performance
- **Action:** If < 90, prioritize optimizations based on Lighthouse suggestions

### Web Vitals

- **LCP (Largest Contentful Paint):** < 2.5s
- **FID (First Input Delay):** < 100ms
- **CLS (Cumulative Layout Shift):** < 0.1

### Apollo Cache Hit Rate

- **Target:** > 70% cache hits for queries
- **Action:** If < 70%, review fetch policies and cache configuration

## Red Flags (Apply Optimization Immediately)

These indicate you **must** optimize:

1. **Lighthouse Performance < 50** ‚Üí Critical performance issues
2. **Bundle size > 1MB** ‚Üí Users on slow connections will struggle
3. **Mutation latency > 1s** ‚Üí Users notice delay
4. **Cache hit rate < 30%** ‚Üí Too many unnecessary requests
5. **LCP > 4s** ‚Üí Poor perceived performance

## When to Skip Optimizations

**Skip optimizations when:**

- ‚úÖ No measurable performance problem exists
- ‚úÖ Optimization adds significant complexity
- ‚úÖ You're in early MVP stage (premature optimization)
- ‚úÖ Users don't notice the difference (< 100ms improvement)
- ‚úÖ Maintenance cost > performance benefit

**Remember:** Clean, maintainable code > micro-optimizations

## Quick Reference: Decision Tree

```
Is there a measurable problem?
‚îú‚îÄ No ‚Üí Skip optimization
‚îî‚îÄ Yes ‚Üí Is it affecting users?
    ‚îú‚îÄ No ‚Üí Skip optimization
    ‚îî‚îÄ Yes ‚Üí What's the complexity?
        ‚îú‚îÄ Low ‚Üí Apply optimization
        ‚îî‚îÄ High ‚Üí Measure ROI
            ‚îú‚îÄ ROI > 2x ‚Üí Apply optimization
            ‚îî‚îÄ ROI < 2x ‚Üí Skip optimization
```

## Examples: Real-World Decisions

### Example 1: E-commerce Product List

**Context:** Product list with 100+ items, filters, sorting

**Optimizations to apply:**

- ‚úÖ Dynamic import for filters component (not always visible)
- ‚úÖ Memoize filtered/sorted results (expensive computation)
- ‚úÖ Apollo Type Policies (products appear in list + detail)
- ‚úÖ Optimistic updates for "Add to Cart" (frequent action)

**Optimizations to skip:**

- ‚ùå Cache persistence (products change frequently)
- ‚ùå Manual cache updates (refetchQueries works fine)

### Example 2: Admin Dashboard

**Context:** Admin panel with charts, tables, used by < 5% of users

**Optimizations to apply:**

- ‚úÖ Dynamic import entire dashboard (rarely accessed)
- ‚úÖ Lazy load charts library (heavy dependency)
- ‚úÖ Cache persistence (admin data changes slowly)

**Optimizations to skip:**

- ‚ùå Optimistic updates (admin actions need confirmation)
- ‚ùå Complex cache policies (simple data structure)

### Example 3: Real-time Chat

**Context:** Chat app with messages updating every second

**Optimizations to apply:**

- ‚úÖ Optimistic updates for sending messages (instant feedback)
- ‚úÖ Virtual scrolling for message list (1000+ messages)

**Optimizations to skip:**

- ‚ùå Cache persistence (data changes constantly)
- ‚ùå Complex cache policies (simple linear list)

## References

- [Apollo Cache Configuration](https://www.apollographql.com/docs/react/caching/cache-configuration/)
- [Next.js Performance](https://nextjs.org/docs/app/building-your-application/optimizing)
- [Web Vitals](https://web.dev/vitals/)
- [Bundle Analysis](https://nextjs.org/docs/app/api-reference/next-config-js/analyze)
